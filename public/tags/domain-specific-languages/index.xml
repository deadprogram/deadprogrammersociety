<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>domain specific languages on Dead Programmer SOciety</title>
    <link>/tags/domain-specific-languages/</link>
    <description>Recent content in domain specific languages on Dead Programmer SOciety</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 24 Oct 2007 09:16:00 -0700</lastBuildDate><atom:link href="/tags/domain-specific-languages/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Sinatra, a Ruby web framework, and Why It Matters</title>
      <link>/2007/10/sinatra-ruby-web-framework-and-why-it.html</link>
      <pubDate>Wed, 24 Oct 2007 09:16:00 -0700</pubDate>
      
      <guid>/2007/10/sinatra-ruby-web-framework-and-why-it.html</guid>
      <description>As followers of this blog know, I am very interested in the Ruby language itself, not just web development. But it is undeniable that Ruby has become popular largely due to web development powered by Ruby on Rails. However amazing Rails is, however, it is not the final web framework to be developed in Ruby.
When Ari Lerner first told me of the Sinatra project, I was interested to see where he was going with it.</description>
    </item>
    
    <item>
      <title>More Developer Fun In Los Angeles</title>
      <link>/2007/10/more-developer-fun-in-los-angeles.html</link>
      <pubDate>Wed, 24 Oct 2007 08:17:00 -0700</pubDate>
      
      <guid>/2007/10/more-developer-fun-in-los-angeles.html</guid>
      <description>Last night was the always entertaining Los Angeles Application Developer Meetup. L.A. is not known for the same massive quantity of developers as the bay area, for example, but having joined forces with the LA Ruby on Rails Meetup crew some time back, the monthly event is still growing.
This month&amp;rsquo;s was held at the impressive new digs of YellowPages.com, who have been busy building out a huge Ruby on Rails based local search replacement for their venerable 100K+ lines of Java code.</description>
    </item>
    
    <item>
      <title>Is Your Database Getting Tired?</title>
      <link>/2007/10/is-your-database-getting-tired.html</link>
      <pubDate>Fri, 19 Oct 2007 07:52:00 -0700</pubDate>
      
      <guid>/2007/10/is-your-database-getting-tired.html</guid>
      <description>Is your database getting old and tired? Mike Stonebraker thinks so. Stonebraker is a database guru and long-time researcher, and when I say database guru I mean one of the founders of Ingres, and former CTO of Informix, not just some guy who knows how to debug a stored procedure.
Here is a juicy quote from a recent article published by MIT of which he is one of the authors:</description>
    </item>
    
    <item>
      <title>Speaking The Same Language</title>
      <link>/2007/01/speaking-same-language.html</link>
      <pubDate>Tue, 23 Jan 2007 09:40:00 -0800</pubDate>
      
      <guid>/2007/01/speaking-same-language.html</guid>
      <description>The art of successful software development is matching the delivered software to the needs of the users. Achieving this requires that the developers and the users speak the same language regarding the problem to be solved. James Shore has a new chapter called Ubiquitous Language in his upcoming agile development book that summarizes this idea nicely.
Martin Fowler&amp;rsquo;s seminal article on Language Workbenches also has really influenced my thinking. I guess the difference to me is that where Ubiquitous Language is about getting the developers to understand what the users are talking about, Language Workbenches are about building software systems using tools to translate the domain specific language into runnable code.</description>
    </item>
    
    <item>
      <title>Ruby Domain Specific Languages - The Basics (Part 4)</title>
      <link>/2006/11/ruby-domain-specific-languages-basics_27.html</link>
      <pubDate>Fri, 12 Jan 2007 16:00:00 -0800</pubDate>
      
      <guid>/2006/11/ruby-domain-specific-languages-basics_27.html</guid>
      <description>In the previous three entries in this series of postings, I have been exploring the basics of creating domain specific languages using Ruby. Since I cannot disclose details of my big financial service client&amp;rsquo;s DSL, I am using this made up example to illustrate the techniques that are useful when building your own Ruby DSL. So far we have created a &amp;ldquo;PetShop&amp;rdquo; domain that allows us to interact with the Pets.</description>
    </item>
    
    <item>
      <title>Ruby Domain Specific Languages - The Basics (Part 3)</title>
      <link>/2006/11/ruby-domain-specific-languages-basics_19.html</link>
      <pubDate>Sun, 19 Nov 2006 15:00:00 -0800</pubDate>
      
      <guid>/2006/11/ruby-domain-specific-languages-basics_19.html</guid>
      <description>This is another installment in a series about creating domain specific languages with Ruby. In part 1 and part 2 of this series, I created a simple Ruby DSL to describe the relationship between Pets and Persons. Now I will extend the DSL, and use some cool Ruby metaprogramming tricks to demonstrate the power and benefits of using Ruby to create an internal DSL.
First, I want to simplify the syntax for declaring things in our DSL.</description>
    </item>
    
    <item>
      <title>Ruby Domain Specific Languages - The Basics (Part 2)</title>
      <link>/2006/11/ruby-domain-specific-languages-basics_08.html</link>
      <pubDate>Wed, 08 Nov 2006 12:29:00 -0800</pubDate>
      
      <guid>/2006/11/ruby-domain-specific-languages-basics_08.html</guid>
      <description>Previously, I was exploring the basics of DSL creation using Ruby. This post continues sharing my lessons learned while developing a prototype of a domain specific language in the mortgage industry. Since I cannot share the actual code itself belonging to my client, I will continue to extract the useful concepts into these simple examples.
Last time we created a simple Animal DSL class. The important part of that class is this bit that makes sure our DSL like syntax works for the declarative methods:</description>
    </item>
    
    <item>
      <title>Ruby Domain Specific Languages - The Basics (Part 1)</title>
      <link>/2006/11/ruby-domain-specific-languages-basics.html</link>
      <pubDate>Sat, 04 Nov 2006 16:36:00 -0800</pubDate>
      
      <guid>/2006/11/ruby-domain-specific-languages-basics.html</guid>
      <description>I have been working on a prototype of a Ruby domain specific language for one of my clients, a very large financial services company. I have learned a whole bunch of really interesting lessons, which I will share over a short series of posts as I make more progress.
The first thing I tried to do was create a basic bit of DSL tastiness like this:
class Dog &amp;lt; Animal number\_of\_legs 4 end class Bird &amp;lt; Animal number\_of\_legs 2 end class Snail &amp;lt; Animal number\_of\_legs 0 end My first implementation of the Animal class looked like this:</description>
    </item>
    
  </channel>
</rss>
